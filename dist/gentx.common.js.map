{"version":3,"file":"gentx.common.js","sources":["../src/utils.js","../src/guards/log.js","../src/source.js","../src/flow.js"],"sourcesContent":["// if condition is false, throw message \nexport function invariant(condition, message) {\n  if (condition) return;\n  throw new Error(message);\n}\n\n// log\nexport function log(...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    console.log(...args);\n  };\n}\n\n// catch error\nexport function catchError(fn) {\n  return function(...args) {\n    try {\n      return fn.bind(this)(...args);\n    } catch (e) {\n      console.log('uncaught exception:', e);\n      throw e;\n    }\n  }\n}","import { map } from 'rxjs/operators';\nimport { log } from '../utils';\n\nexport function logGuard(input, opts={}) {\n  let {flowName, groupName, guardType} = opts;\n\n  // not use as a middleware\n  if (!guardType) return input;\n\n  let typeMsg = { before: 'in', after: 'out' }[guardType];\n\n  return input.pipe(\n    map(value => {\n      let logData;\n      \n      try {\n        logData = JSON.parse(JSON.stringify(value));\n      } catch(e) {\n        logData = e.message;\n      }\n\n      log(`[gentx log] ~ flow ${typeMsg} <${groupName}>.<${flowName}>:`, logData);\n\n      return value;\n    })\n  );\n}\n","import { Observable, from } from 'rxjs';\n\n// create observable from a `observable input` and a `cancel function`\nexport function makeObservable(input, cancel) {\n  let observable = from(input);\n  return Observable.create(observer => {\n    let subscription = observable.subscribe(observer);\n    return function unsubscribe() {\n      if (typeof cancel === 'function') cancel();\n      subscription.unsubscribe();\n    }\n  });\n}","import { concatMap, mergeMap, switchMap } from 'rxjs/operators';\n\n// concatMap source to flow\nexport function concatMapSource(source) {\n  return (input) => {\n    return input.pipe(\n      concatMap((value) => source(value))\n    );\n  };\n}\n\n// mergeMap source to flow\nexport function mergeMapSource(source) {\n  return (input) => {\n    return input.pipe(\n      mergeMap((value) => source(value))\n    );\n  };\n}\n\n// switchMap source to flow\nexport function switchMapSource(source) {\n  return (input) => {\n    return input.pipe(\n      switchMap((value) => source(value))\n    );\n  };\n}\n\n// create a flows group\nexport function groupFlows(flowMap={}, opts={}) {\n  const {\n    groupName= 'Anonymous',\n    beforeGuards= [],\n    afterGuards= []\n  } = opts;\n  const flows = {};\n\n  Object.keys(flowMap).forEach(key => {\n    const originFlow = flowMap[key];\n    // before middlewares\n    const befores = beforeGuards.map(guard => {\n      return (input, opts={}) => {\n        return guard(input, { \n          ...opts,\n          guardType: 'before',  \n          flowName: key,\n          groupName: groupName\n        });\n      }\n    });\n    // after middlewares\n    const afters = afterGuards.map(guard => {\n      return (input, opts={}) => {\n        return guard(input, { \n          ...opts,\n          guardType: 'after',  \n          flowName: key,\n          groupName: groupName\n        });\n      }\n    });\n    // concat middlewares with flow\n    const fns = befores.concat(originFlow).concat(afters);\n    // generate flow\n    const flow = function flow(input, opts={}) {\n      return fns.reduce((prev, currFn) => currFn(prev, opts), input);\n    }\n\n    flows[key] = flow;\n  });\n\n  return flows;\n}\n\n// create flow from source\nexport function flowSource(source, operatorType='concatMap') {\n  let operator = {\n    'concatMap': concatMapSource,\n    'mergeMap': mergeMapSource,\n    'switchMap': switchMapSource\n  }[operatorType];\n\n  if (!operator) {\n    throw new Error(`[gentx error] operatorType must in ['concatMap', 'mergeMap', 'switchMap'], but get <${operatorType}> when flowSource <${source.name}>.`)\n  }\n\n  return operator(source);\n}\n\n// crate flows from sources\nexport function flowSources(sourceMap, operatorType='concatMap') {\n  const flows = {};\n\n  Object.keys(sourceMap).forEach(key => {\n    let source = sourceMap[key];\n    flows[key] = flowSource(source, operatorType);\n  });\n\n  return flows;\n}"],"names":["log","process","env","NODE_ENV","catchError","fn","bind","e","logGuard","input","opts","flowName","groupName","guardType","typeMsg","before","after","pipe","map","logData","JSON","parse","stringify","value","message","makeObservable","cancel","observable","from","Observable","create","subscription","subscribe","observer","unsubscribe","concatMapSource","source","concatMap","mergeMapSource","mergeMap","switchMapSource","switchMap","groupFlows","flowMap","beforeGuards","afterGuards","flows","keys","forEach","originFlow","key","befores","guard","afters","fns","concat","flow","reduce","prev","currFn","flowSource","operatorType","operator","Error","name","flowSources","sourceMap"],"mappings":";;;;;;;AAAA;AACA;;AAMA,AAAO,SAASA,GAAT,GAAsB;MACvBC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;;;yBACjCH,GAAR;GAEH;;;AAGD,AAAO,SAASI,UAAT,CAAoBC,EAApB,EAAwB;SACtB,YAAkB;QACnB;aACKA,GAAGC,IAAH,CAAQ,IAAR,6BAAP;KADF,CAEE,OAAOC,CAAP,EAAU;cACFP,GAAR,CAAY,qBAAZ,EAAmCO,CAAnC;YACMA,CAAN;;GALJ;;;ACZK,SAASC,QAAT,CAAkBC,KAAlB,EAAkC;MAATC,IAAS,uEAAJ,EAAI;MAClCC,QADkC,GACAD,IADA,CAClCC,QADkC;MACxBC,SADwB,GACAF,IADA,CACxBE,SADwB;MACbC,SADa,GACAH,IADA,CACbG,SADa;;;;MAInC,CAACA,SAAL,EAAgB,OAAOJ,KAAP;;MAEZK,UAAU,EAAEC,QAAQ,IAAV,EAAgBC,OAAO,KAAvB,GAA+BH,SAA/B,CAAd;;SAEOJ,MAAMQ,IAAN,CACLC,cAAI,iBAAS;QACPC,gBAAJ;;QAEI;gBACQC,KAAKC,KAAL,CAAWD,KAAKE,SAAL,CAAeC,KAAf,CAAX,CAAV;KADF,CAEE,OAAMhB,CAAN,EAAS;gBACCA,EAAEiB,OAAZ;;;gCAGwBV,OAA1B,UAAsCF,SAAtC,WAAqDD,QAArD,SAAmEQ,OAAnE;;WAEOI,KAAP;GAXF,CADK,CAAP;;;ACTF;AACA,AAAO,SAASE,cAAT,CAAwBhB,KAAxB,EAA+BiB,MAA/B,EAAuC;MACxCC,aAAaC,UAAKnB,KAAL,CAAjB;SACOoB,gBAAWC,MAAX,CAAkB,oBAAY;QAC/BC,eAAeJ,WAAWK,SAAX,CAAqBC,QAArB,CAAnB;WACO,SAASC,WAAT,GAAuB;UACxB,OAAOR,MAAP,KAAkB,UAAtB,EAAkCA;mBACrBQ,WAAb;KAFF;GAFK,CAAP;;;;;;;;;;;;;;;;;ACHF;AACA,AAAO,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;SAC/B,UAAC3B,KAAD,EAAW;WACTA,MAAMQ,IAAN,CACLoB,oBAAU,UAACd,KAAD;aAAWa,OAAOb,KAAP,CAAX;KAAV,CADK,CAAP;GADF;;;;AAQF,AAAO,SAASe,cAAT,CAAwBF,MAAxB,EAAgC;SAC9B,UAAC3B,KAAD,EAAW;WACTA,MAAMQ,IAAN,CACLsB,mBAAS,UAAChB,KAAD;aAAWa,OAAOb,KAAP,CAAX;KAAT,CADK,CAAP;GADF;;;;AAQF,AAAO,SAASiB,eAAT,CAAyBJ,MAAzB,EAAiC;SAC/B,UAAC3B,KAAD,EAAW;WACTA,MAAMQ,IAAN,CACLwB,oBAAU,UAAClB,KAAD;aAAWa,OAAOb,KAAP,CAAX;KAAV,CADK,CAAP;GADF;;;;AAQF,AAAO,SAASmB,UAAT,GAAyC;MAArBC,OAAqB,uEAAb,EAAa;MAATjC,IAAS,uEAAJ,EAAI;wBAK1CA,IAL0C,CAE5CE,SAF4C;MAE5CA,SAF4C,mCAEjC,WAFiC;2BAK1CF,IAL0C,CAG5CkC,YAH4C;MAG5CA,YAH4C,sCAG9B,EAH8B;0BAK1ClC,IAL0C,CAI5CmC,WAJ4C;MAI5CA,WAJ4C,qCAI/B,EAJ+B;;MAMxCC,QAAQ,EAAd;;SAEOC,IAAP,CAAYJ,OAAZ,EAAqBK,OAArB,CAA6B,eAAO;QAC5BC,aAAaN,QAAQO,GAAR,CAAnB;;QAEMC,UAAUP,aAAa1B,GAAb,CAAiB,iBAAS;aACjC,UAACT,KAAD,EAAoB;YAAZC,IAAY,uEAAP,EAAO;;eAClB0C,MAAM3C,KAAN,eACFC,IADE;qBAEM,QAFN;oBAGKwC,GAHL;qBAIMtC;WAJb;OADF;KADc,CAAhB;;QAWMyC,SAASR,YAAY3B,GAAZ,CAAgB,iBAAS;aAC/B,UAACT,KAAD,EAAoB;YAAZC,IAAY,uEAAP,EAAO;;eAClB0C,MAAM3C,KAAN,eACFC,IADE;qBAEM,OAFN;oBAGKwC,GAHL;qBAIMtC;WAJb;OADF;KADa,CAAf;;QAWM0C,MAAMH,QAAQI,MAAR,CAAeN,UAAf,EAA2BM,MAA3B,CAAkCF,MAAlC,CAAZ;;QAEMG,OAAO,SAASA,IAAT,CAAc/C,KAAd,EAA8B;UAATC,IAAS,uEAAJ,EAAI;;aAClC4C,IAAIG,MAAJ,CAAW,UAACC,IAAD,EAAOC,MAAP;eAAkBA,OAAOD,IAAP,EAAahD,IAAb,CAAlB;OAAX,EAAiDD,KAAjD,CAAP;KADF;;UAIMyC,GAAN,IAAaM,IAAb;GA/BF;;SAkCOV,KAAP;;;;AAIF,AAAO,SAASc,UAAT,CAAoBxB,MAApB,EAAsD;MAA1ByB,YAA0B,uEAAb,WAAa;;MACvDC,WAAW;iBACA3B,eADA;gBAEDG,cAFC;iBAGAE;IACbqB,YAJa,CAAf;;MAMI,CAACC,QAAL,EAAe;UACP,IAAIC,KAAJ,gGAAiGF,YAAjG,2BAAmIzB,OAAO4B,IAA1I,QAAN;;;SAGKF,SAAS1B,MAAT,CAAP;;;;AAIF,AAAO,SAAS6B,WAAT,CAAqBC,SAArB,EAA0D;MAA1BL,YAA0B,uEAAb,WAAa;;MACzDf,QAAQ,EAAd;;SAEOC,IAAP,CAAYmB,SAAZ,EAAuBlB,OAAvB,CAA+B,eAAO;QAChCZ,SAAS8B,UAAUhB,GAAV,CAAb;UACMA,GAAN,IAAaU,WAAWxB,MAAX,EAAmByB,YAAnB,CAAb;GAFF;;SAKOf,KAAP;;;;;;;;;;"}